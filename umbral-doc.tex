
\documentclass[12pt]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{geometry} % see geometry.pdf on how to lay out the page. There's lots.
\geometry{a4paper} % or letter or a5paper or ... etc
\usepackage[utf8]{inputenc}
\usepackage{url}

\title{Umbral: a threshold proxy re-encryption scheme}
\author{David Núñez}
\date{} % delete this line to display the current date

%%% BEGIN DOCUMENT



\begin{document}

\maketitle

\begin{abstract}
This document describes the Umbral proxy re-encryption scheme used by NuCypher KMS. 
Umbral is a threshold proxy re-encryption scheme based on ECIES-KEM \cite{ansi-x9.63} and BBS98 \cite{blaze1998divertible}. 

%The name ``Umbral'' comes from the Spanish word for ``threshold''. 
%Umbral ciphertexts have the same form than ECIES-KEM ciphertexts

\end{abstract}

%\tableofcontents


\section{Introduction}

\section{Preliminaries}

\subsection{Notation}

Although the additive notation is the norm when dealing with elliptic curve cryptography, in this document we adopt the multiplicative notation to express the operations in the elliptic curve group, which is the usual approach in the proxy re-encryption literature (where schemes are defined in generic groups).

\subsection{Proxy Re-Encryption}

(TODO: General description of proxy re-encryption, properties, etc)

\subsection{ECIES}

The Asymmetric Encryption Scheme defined in standard ANSI X9.63 \cite{ansi-x9.63}, also known as Elliptic Curve Integrated Encryption Scheme (ECIES), is a hybrid encryption algorithm based on elliptic curve cryptography, symmetric encryption and message authentication codes. 
This algorithm is of public knowledge, and variants have been standardized also by ISO/IEC 18033-2 \cite{iso-18033-2} and IEEE P1363A \cite{ieee-p1363a}. A brief comparison of the different variants of ECIES can be found in \cite{martinez2010comparison}. 

When producing a ciphertext with ECIES, the sender first creates an ephemeral public key and uses it for a Diffie-Hellman key agreement together with the public key of the intended recipient. The resulting shared secret is used to create the keys for the symmetric encryption and message authentication code algorithms used internally. The final ciphertext consists of the ephemeral public key, as it is necessary for decryption, and the output of the symmetric encryption and message authentication code.

A Sender can  be any entity that generates data and wants to send it confidentially to a receiver, in the form of a ciphertext encrypted under the public key of the receiver. 

A Receiver can be any entity that is entitled to read ciphertexts encrypted under his public key. We distinguish two types of receivers. The original receiver, which is the recipient of the data originally intended by the sender, and the delegated receiver, whom the original receiver entrusts to be able to decrypt ciphertexts initially intended to him. Therefore, there is a relation of delegation between the original receiver and the delegated one. 

The Intermediary is an entity that controls the process of switching the public key of ciphertexts, from the public key of the original receiver to the public key of a delegated receiver, without being able to learn anything from the data. The Intermediary needs a key-switching key between the original and delegated receivers in order to be able to perform the key-switching process.

ECIES can be used in a variety of elliptic curves, but we will restrict the choice of elliptic curves in our cryptosystem to those that generate a group of prime order. %ECIES define procedures for encryption and decryption, as well as defines 

\section{The Umbral PRE cryptosystem}

In this section we present the Umbral PRE cryptosystem, defined by the following algorithms:

\begin{itemize}
	%\item $\mathsf{Setup}(1^k)\rightarrow params$. On input the security parameter $1^k$, the global setup algorithm $\mathsf{Setup}$ outputs the global parameters $params$.
	\item $\mathsf{KeyGen}()$: Sample $x \in \mathbb Z_q$, compute $g^x$ and output the keypair $(pk, sk) = (g^x, x)$.
%	\item $\mathsf{ReKeyGen}(\sk{A}, \sk{B})$: On input the secret keys $\sk{A} = f_A$ and $\sk{B} = f_B$, the re-encryption key generation algorithm $\mathsf{ReKeyGen}$ computes the re-encryption key between users $A$ and $B$ as $\rk{A}{B} = \sk{A} \cdot \sk{B}^{-1} = f_A \cdot \invfB $.
	
	\item $\mathsf{Enc}(pk_A, M)$: On input the public key $pk_A$ and a message $M\in\mathcal{M}$, the encryption algorithm $\mathsf{Enc}$ first computes $(K, encKey) = \mathsf{Encapsulate}(pk_A)$.  
	%$EPK$ is the byte encoding of the point $epk$. 
	$encData$ is the result of applying the authenticated encryption algorithm to $M$ with key $K$. 
	Finally, it outputs the ciphertext $C = (encKey, encData)$.
	
		\item $\mathsf{Dec}(sk_A, C)$: On input the secret key $sk_A$ and a ciphertext $C = (encKey, encData)$, the decryption algorithm $\mathsf{Dec}$ %first parses $C$ as $EPK||AE$, and decodes $epk$ from its byte representation $EPK$. Next, it 
		computes the key $K = \mathsf{Decapsulate}(sk_A, epk)$, and decrypts ciphertext $AE$ using the decryption function of the AE scheme to obtain message $M$ if decryption is correct, and $\perp$ otherwise. Finally, it outputs message $M$ (or $\perp$ if decryption was invalid).
		
		\item $\mathsf{DecFrag}(sk_A, \{F_i\}_{i=1}^t, AE)$: On input the secret key $sk_A$ and a set of $t$ fragments of an encapsulated key, each of them labeled as $F_i$, and the encrypted data $encData$, the fragments decryption algorithm $\mathsf{DecFrag}$ first computes $encKey' = \mathsf{Combine}(\{F_i\}_{i=1}^t)$. With this result, it returns the result of $\mathsf{Dec}(sk_A, C')$, where $C' = (encKey', encData)$. % is the byte representation of $epk'$.

	
	\item $\mathsf{ReEncFrag}(kFrag, encKey)$: On input a re-encryption key fragment $kFrag$, and an encapsulated key $encKey$, the fragmented re-encryption algorithm $\mathsf{ReEncFrag}$ first parses $kFrag = (rk, id)$, 
	and computes $encKey' = (encKey)^{rk}$. Finally it outputs the encapsulated key fragment $F = (encKey', id)$. 
\end{itemize}

\textbf{Auxiliary Functions}
\begin{itemize}
	\item $\mathsf{Encapsulate}(pk_A)$: On input the public key $pk_A$, %and a message $M\in\mathcal{M}$, 
	the encapsulation algorithm $\mathsf{Encapsulate}$ first randomly generates an ephemeral keypair $(epk, esk) = (g^r, r)$, performs a Diffie-Hellman key agreement between $pk_A$ and $esk$ to compute a shared secret $S_A$, and uses this shared secret as input to the KDF to produce the key $K$. The encapsulated key $encKey$ is the ephemeral public key $epk$. Finally, it outputs $(K, encKey)$.
	\item $\mathsf{Decapsulate}(sk_A, encKey)$: On input the secret key $pk_A$, and and encapsulated key $encKey$, the decapsulation algorithm $\mathsf{Decapsulate}$ first checks that $encKey$ is a valid public key. 
	Next, it performs a Diffie-Hellman key agreement between $encKey$ and $sk_A$ to compute a shared secret $S_A$, and uses this shared secret as input to a KDF to produce the key $K$. Finally, it outputs $K$.
	\item $\mathsf{Combine}(\{F_i\}_{i=1}^t)$: On input a set of $t$ fragments of an encapsulated key, each of them labeled as $F_i$, the combination algorithm $\mathsf{Combine}$, first parses each fragment $F_i$ as $(encKey_i, id_i)$. %$EPK_i||AE_i||ID_i$, and decodes both $EPK_i$ and $ID_i$ into $epk_i$ and $id_i$, respectively.
Let $I = \{id_i\}_{i=1}^t$. Next, it computes the value $encKey'$ as follows:
$$encKey' = \prod\limits_{i=1}^{t} (encKey_i)^{\lambda_{i, I}}
\text{, where } \lambda_{i, I} = \prod\limits_{j=1, j\neq i}^{t} \frac{id_j}{id_j-id_i}$$
Finally, it outputs $epk'$.
\end{itemize}

\subsection{Parameters of Umbral instantiation in NuCypher KMS}

%secp256k1 curve
% AE scheme: NaCL SecretBox (ChaCha20-Poly1305)

\bibliographystyle{abbrv}       % APS-like style for physics
\bibliography{umbral-doc}
\end{document}